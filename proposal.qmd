---
title: "IOT Network Intrusion Detection Analysis"
subtitle: "Proposal"
author: 
  - name: "ViZZards"
    affiliations:
      - name: "School of Information, University of Arizona"
description: "This project aims to analyze and visualize network attacks within Internet of Things (IoT) environments using the RT-IoT 2022 dataset, which includes network traffic data from both normal and malicious activities across various IoT devices. By examining metrics like protocol usage, bandwidth, payload size, and flow characteristics, the study seeks to identify distinctive patterns associated with different types of attacks. These insights will contribute to developing more effective intrusion detection strategies, enhancing cybersecurity within IoT systems. Ethical considerations are minimal, as the dataset excludes sensitive information."

format:
  html:
    code-tools: true
    code-overflow: wrap
    code-line-numbers: true
    embed-resources: true
editor: visual
code-annotations: hover
execute:
  warning: false
---

```{r}
#| label: load-pkgs
#| message: false
if (!require(pacman)) 
  install.packages("pacman")

pacman::p_load(
  # Core data manipulation and visualization
  tidyverse,
  glue,
  scales,
  ggplot2,
  grid,
  readr,
  corrplot,
  dplyr,
  
  # Shiny and dashboard packages
  shiny,
  shinydashboard,
  DT,
  plotly,
  
  # Additional visualization packages
  viridis,
  RColorBrewer,
  
  # Data manipulation
  data.table,
  tibble,
  
  # Interactive features
  htmlwidgets,
  
  # Dashboard themes and styling
  shinythemes,
  
  # Additional utilities
  stringr,
  lubridate,
  forcats,
  purrr,
  tidyr,
  magrittr
)


```

## Dataset

```{r}
#| label: load-dataset
#| message: false


data <- read_csv("data/data.csv")

glimpse(data)
summary(data)
```

```{r}

# First, close all connections and clear environment
rm(list = ls())
gc()

# Create a vector of required packages
required_packages <- c("shiny", "shinydashboard", "ggplot2", "dplyr", "plotly", "DT")

# Function to install missing packages
install_if_missing <- function(package) {
  if (!requireNamespace(package, quietly = TRUE)) {
    try(install.packages(package, dependencies = TRUE))
  }
}

# Install missing packages
sapply(required_packages, install_if_missing)

# Load packages
library(shiny)
library(shinydashboard)
library(ggplot2)
library(dplyr)
library(plotly)
library(DT)

# Read the data
data <- read.csv("data/data.csv")

# Verify data loading
print("Data dimensions:")
print(dim(data))
print("First few rows:")
print(head(data))

```

### Questions 1 Explonatory

```{r}
# Load Required Libraries
library(shiny)
library(bslib)
library(plotly)
library(dplyr)

# Define UI
ui <- navbarPage(
  title = "IoT Network Attack Analysis",
  
  # Page 1: Attack Type Distribution
  tabPanel(
    "Attack Type Distribution",
    page_fillable(
      card(
        card_header("Attack Type Distribution (Pie Chart with Hover Zoom)"),
        layout_sidebar(
          sidebar = sidebar(
            bg = "lightgrey",
            h3("Legend Selection"),
            checkboxGroupInput("selected_attacks", "Select Attack Types to Display:", 
                               choices = NULL, selected = NULL) # Populated dynamically
          ),
          plotlyOutput("attack_pie_chart", height = "600px")
        )
      )
    )
  ),
  
  # Page 2: Protocol Distribution
  tabPanel(
    "Protocol Distribution",
    page_sidebar(
      title = "Protocol Distribution Dashboard",
      sidebar = sidebar(
        checkboxGroupInput(
          "protocol_filters",
          "Select Protocols:",
          choices = c("UDP", "TCP", "ICMP"),
          selected = c("UDP", "TCP", "ICMP") # Default: all selected
        )
      ),
      card(
        card_header("Protocol Distribution by Attack Type"),
        plotlyOutput("protocol_plot", height = "600px")
      )
    )
  ),
  
  # Page 3: Service Distribution
  tabPanel(
    "Service Distribution",
    page_sidebar(
      title = "Service Distribution Dashboard",
      sidebar = sidebar(
        checkboxGroupInput(
          "service_filters",
          "Select Services:",
          choices = NULL, # Dynamically populated
          selected = NULL  # Default: all selected
        )
      ),
      card(
        card_header("Service Distribution by Attack Type"),
        plotlyOutput("service_plot", height = "600px")
      )
    )
  )
)

# Define Server Logic
server <- function(input, output, session) {
  # Page 1: Attack Type Distribution
  truncated_data <- reactive({
    data %>%
      count(Attack_type) %>%
      arrange(desc(n)) %>%
      mutate(
        Attack_type = ifelse(nchar(Attack_type) > 20, 
                             paste0(substr(Attack_type, 1, 17), "..."), 
                             Attack_type)
      )
  })
  
  observe({
    updateCheckboxGroupInput(
      session,
      "selected_attacks",
      choices = truncated_data()$Attack_type,
      selected = truncated_data()$Attack_type # Default: Select all
    )
  })
  
  filtered_data <- reactive({
    if (is.null(input$selected_attacks)) {
      return(truncated_data()) # Show all if no selection
    }
    truncated_data() %>%
      filter(Attack_type %in% input$selected_attacks)
  })
  
  output$attack_pie_chart <- renderPlotly({
    attack_dist <- filtered_data()
    plot_ly(
      attack_dist, 
      labels = ~Attack_type, 
      values = ~n, 
      type = "pie",
      textinfo = "label+percent",
      insidetextorientation = "horizontal",
      textposition = "outside",
      hoverinfo = "label+percent+value",
      pull = rep(0, nrow(attack_dist)), # No slices pulled by default
      marker = list(colors = RColorBrewer::brewer.pal(n = nrow(attack_dist), name = "Set2")),
      domain = list(x = c(0.2, 0.8), y = c(0.1, 0.6))
    ) %>%
      layout(
        title = list(text = " "),
        annotations = list(
          text = "Attack Type Distribution",
          showarrow = FALSE,
          x = 0.5,
          y = -0.15,
          xref = "paper",
          yref = "paper",
          font = list(size = 16, color = "black")
        )
      )
  })
  
# Page 2: Protocol Distribution
filtered_protocol_data <- reactive({
  req(input$protocol_filters) # Ensure filters are selected
  # Normalize protocol values to uppercase for comparison
  data %>%
    filter(toupper(proto) %in% toupper(input$protocol_filters)) # Case-insensitive match
})

output$protocol_plot <- renderPlotly({
  protocol_dist <- filtered_protocol_data() %>%
    group_by(Attack_type, proto) %>%
    summarise(count = n(), .groups = "drop") %>%
    arrange(desc(count))
  
  # Check if data is empty
  validate(
    need(nrow(protocol_dist) > 0, "No data available for the selected protocols.")
  )
  
  plot_ly(
    protocol_dist, 
    x = ~Attack_type, 
    y = ~count, 
    color = ~proto, 
    type = "bar"
  ) %>%
    layout(
      barmode = "stack",
      title = "Protocol Distribution by Attack Type",
      xaxis = list(title = "Attack Type", tickangle = 45),
      yaxis = list(title = "Attack Count")
    )
})
  
  # Page 3: Service Distribution
  observe({
    updateCheckboxGroupInput(
      session,
      "service_filters",
      choices = unique(data$service), # Dynamically populate services
      selected = unique(data$service) # Default: all selected
    )
  })
  
  filtered_service_data <- reactive({
    req(input$service_filters)
    data %>%
      filter(service %in% input$service_filters)
  })
  
  output$service_plot <- renderPlotly({
    service_dist <- filtered_service_data() %>%
      group_by(Attack_type, service) %>%
      summarise(count = n(), .groups = "drop") %>%
      arrange(desc(count))
    
    plot_ly(
      service_dist, 
      x = ~Attack_type, 
      y = ~count, 
      color = ~service, 
      type = "bar"
    ) %>%
      layout(
        barmode = "stack",
        title = "Service Distribution by Attack Type",
        xaxis = list(title = "Attack Type", tickangle = 45),
        yaxis = list(title = "Attack Count")
      )
  })
}

# Run the App
shinyApp(ui = ui, server = server)



```

### Description

The dataset consists of 123,117 rows and 77 columns, capturing network traffic flow data. Key features include:

-   **Network Identifiers:** Columns like id.orig_p and id.resp_p capture originating and responding port IDs.

-   **Protocol and Service Information:** Columns such as proto (protocol) and service (e.g., MQTT) identify the communication protocol and services in use.

-   **Traffic Statistics:** These include metrics like packet counts (fwd_pkts_tot, bwd_pkts_tot), packet rates (fwd_pkts_per_sec), and header sizes.

-   **Flow Characteristics:** Features like flow duration (flow_duration), and flags such as flow_FIN_flag_count, flow_ACK_flag_count,flow_SYN_flag_count flow_RST_flag_count capture communication patterns.

-   **Attack Type:** The Attack_type column labels the type of attack or event detected (e.g., MQTT_Publish).

-   **Payload Information:** This payload information describes the size of packets that is flowing through the network during an attack vs normal traffic for eg : fwd_pkts_payload.avg,fwd_pkts_payload.min, fwd_pkts_payload.max which will be higher during an attack.

-   **Bandwidth Information:** The amount of data flowing through IOT infrastructure varies during different type of attack for e.g. during DDOS slowloris is denial of service attack where the data flow is much higher in comparison to normal traffic. So these variables are used for bandwidth information fwd_pkts_tot, bwd_pkts_tot, fwd_data_pkts_tot, bwd_data_pkts_tot,fwd_pkts_per_sec, bwd_pkts_per_sec, flow_pkts_per_sec.

-   **Inter-arrival time information:** Variables like fwd_iat.min, fwd_iat.avg, flow_iat.min can be used to determine what is the time difference between two packets which corresponds to payload information as the payload gets bigger IAT and IAT flow time will be larger.

-   **Idle vs In-use information:** active.avg , idle.avg will provide the information about the IOT devices if it is forwarding or not forwarding the network traffic.

The dataset appears to be useful for studying network behavior, identifying attacks, and analyzing flow-based communication statistics.

### Source of the data

The RT-IoT 2022 dataset, available from the UCI Machine Learning Repository, is designed for research on detecting attacks in IoT (Internet of Things) systems. It contains network flow data from various IoT devices and captures both normal and malicious traffic, making it valuable for studying cybersecurity in IoT environments. The dataset includes features such as packet counts, traffic flow statistics, and communication protocols, which are essential for intrusion detection and anomaly analysis in smart systems. Researchers often use it to train machine learning models to detect cyberattacks.

### Dataset Generation

The RT-IoT2022 dataset was specifically created to train and test the IDS. The dataset comprises normal and attack traffic, captured using real-time IoT devices like ThingSpeak-LED, MQTT-Temp, Amazon Alexa, and Wipro Bulb. The authors used a router setup to connect both victim (IoT devices) and attacker devices, capturing network traffic through the open-source tool Wireshark, which recorded and converted traces into PCAP files.

**Attack Simulation:** SSH Brute-Force Attack: Metasploit’s modules were employed to launch SSH brute-force attacks after scanning for open ports using Nmap. DDoS Attack: The Hping3 tool from Kali Linux was utilized to generate DDoS attacks, transmitting thousands of packets to simulate high traffic.

**Feature Engineering:** The collected PCAP files were processed using the CICFlowmeter tool, converting the network traffic data into bidirectional flow features for analysis. Irrelevant information like source and destination addresses were removed, and categorical features were numerically encoded to prevent overfitting. This method ensured a realistic and comprehensive dataset, encompassing both benign and malicious IoT traffic, critical for developing and testing the QAE IDS model.

## Questions

The following are the question will be used for our project:-

-   Which protocol, service and port number is used in different type of attack scenarios to avoid any future network cyber attacks ?

-   How do different type of attack show unique patterns across bandwidth, inter arrival time, payload and flow characteristics ? Are these patterns showing any reliable distinctions between attacks ?

-   Which combinations of dimensions is responsible for the different type of attack ?

## Analysis plan

Question 1:

-   Variable proto , service and id.resp_p will be used and compared with different type of attacks vs when actual devices is talking over same protocol, service and port number.

Question 2:

-   A relationship between variables that corresponds to bandwidth information for e.g. fwd_pkts_tot, bwd_pkts_tot, fwd_data_pkts_tot, bwd_data_pkts_tot, fwd_pkts_per_sec, bwd_pkts_per_sec, flow_pkts_per_sec with attack type will be determined. This will define the clear relationship of bandwidth during an attack

-   Inter-arrival time information which will use variables like fwd_iat.min, fwd_iat.avg, flow_iat.min to make similar relationship during an attack vs normal operation.

-   Every attack type prohibit different payload behaviour. We will use the variables fwd_pkts_payload.avg,fwd_pkts_payload.min, fwd_pkts_payload.max to find out extreme large packet and empty packet

-   DDOS slowloris attack uses TCP SYNC message flooding through the server with the flow characterstics information we will compare number of TCP SYNC message with the number of other TCP messages

Question 3:

-   With comparison of different variables in attack scenarios we will determine who and how many dimensions are affected during attacks

## Ethical concerns

Our dataset do not have any ethical concerns because basic information of internal organization is not included. We are visualising and analysing without source and destination specified which has its pros and cons.

## Citations

| Dataset : [UCI Machine Learning Repository](https://archive.ics.uci.edu/dataset/942/rt-iot2022)
